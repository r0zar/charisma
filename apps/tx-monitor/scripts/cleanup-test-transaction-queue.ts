#!/usr/bin/env node

/**
 * Script to clean up test transaction IDs from the transaction queue
 * This prevents test activities from being regenerated by the cron job
 * Usage: pnpm script scripts/cleanup-test-transaction-queue.ts
 */

import { logger } from './logger';
import { kv } from '@vercel/kv';

async function cleanupTestTransactionQueue() {
  await logger.info('üßπ Cleaning up test transaction IDs from queue');
  
  try {
    // Get all items in transaction queue
    const queueMembers = await kv.smembers('tx:queue');
    
    if (!queueMembers || queueMembers.length === 0) {
      await logger.success('‚úÖ Transaction queue is empty');
      return;
    }
    
    await logger.info(`üìä Found ${queueMembers.length} items in transaction queue`);
    
    const testTxids = [];
    const realTxids = [];
    
    // Identify test transaction IDs
    for (const txid of queueMembers) {
      const isTest = 
        txid.includes('test-') ||
        txid.includes('TEST') ||
        txid.startsWith('dummy-') ||
        txid.startsWith('fake-') ||
        txid === 'unknown' ||
        // Common test patterns
        /^test-txid-\d+-\d+$/.test(txid);
      
      if (isTest) {
        testTxids.push(txid);
      } else {
        realTxids.push(txid);
      }
    }
    
    await logger.info(`üìä Identified ${testTxids.length} test transaction IDs`);
    await logger.info(`üìä Will preserve ${realTxids.length} real transaction IDs`);
    
    if (testTxids.length === 0) {
      await logger.success('‚úÖ No test transaction IDs found in queue');
      return;
    }
    
    // Show test txids to be removed
    await logger.info(`\n‚ö†Ô∏è  TEST TRANSACTION IDs TO REMOVE:`);
    for (const txid of testTxids) {
      await logger.info(`     ${txid}`);
    }
    
    if (realTxids.length > 0) {
      await logger.info(`\n‚úÖ REAL TRANSACTION IDs TO PRESERVE:`);
      for (const txid of realTxids) {
        await logger.info(`     ${txid}`);
      }
    }
    
    // Remove test transaction IDs from queue
    await logger.info(`\nüóëÔ∏è  Removing ${testTxids.length} test transaction IDs from queue...`);
    
    let removedCount = 0;
    for (const txid of testTxids) {
      try {
        const removed = await kv.srem('tx:queue', txid);
        if (removed) {
          removedCount++;
          await logger.info(`   Removed: ${txid}`);
        }
      } catch (error) {
        await logger.error(`   Failed to remove ${txid}: ${String(error)}`);
      }
    }
    
    // Also clean up related transaction data
    await logger.info(`\nüßπ Cleaning up related transaction data...`);
    
    let cleanedMappings = 0;
    let cleanedStatus = 0;
    let cleanedAdded = 0;
    
    for (const txid of testTxids) {
      try {
        // Remove transaction mapping
        const mappingKey = `tx_mapping:${txid}`;
        const mappingRemoved = await kv.del(mappingKey);
        if (mappingRemoved) {
          cleanedMappings++;
        }
        
        // Remove transaction status cache
        const statusKey = `tx:status:${txid}`;
        const statusRemoved = await kv.del(statusKey);
        if (statusRemoved) {
          cleanedStatus++;
        }
        
        // Remove transaction added timestamp
        const addedKey = `tx:added:${txid}`;
        const addedRemoved = await kv.del(addedKey);
        if (addedRemoved) {
          cleanedAdded++;
        }
        
      } catch (error) {
        await logger.error(`   Failed to clean data for ${txid}: ${String(error)}`);
      }
    }
    
    // Final verification
    const finalQueueMembers = await kv.smembers('tx:queue');
    const finalQueueSize = finalQueueMembers?.length || 0;
    
    await logger.info(`\nüìä CLEANUP RESULTS:`);
    await logger.info(`   Removed from queue: ${removedCount}/${testTxids.length} test transactions`);
    await logger.info(`   Cleaned mappings: ${cleanedMappings} mappings`);
    await logger.info(`   Cleaned status cache: ${cleanedStatus} statuses`);
    await logger.info(`   Cleaned timestamps: ${cleanedAdded} timestamps`);
    await logger.info(`   Final queue size: ${finalQueueSize} transactions`);
    
    if (removedCount === testTxids.length) {
      await logger.success('‚úÖ Successfully removed all test transaction IDs from queue');
      await logger.info(`üí° This should prevent test activities from being regenerated by the cron job`);
    } else {
      await logger.warn(`‚ö†Ô∏è  Only removed ${removedCount}/${testTxids.length} test transactions`);
    }
    
  } catch (error) {
    await logger.error('‚ùå Error during cleanup: ' + String(error));
    throw error;
  }
}

async function main() {
  try {
    await cleanupTestTransactionQueue();
  } catch (error) {
    await logger.error('Script failed: ' + String(error));
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

export { cleanupTestTransactionQueue };