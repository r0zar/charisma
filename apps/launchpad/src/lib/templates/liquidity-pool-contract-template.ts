/**
 * Liquidity Pool Contract Template Generator
 */

/**
 * Options for Liquidity Pool contract generation
 * 
 * IMPORTANT: Never assume decimal places for any tokens. Always obtain the official
 * decimal places from token metadata via API or on-chain data.
 * 
 * - For STX: 6 decimals
 * - For sBTC: 8 decimals 
 * - For most other tokens: 6 decimals, but ALWAYS verify
 * 
 * The tokenADecimals and tokenBDecimals parameters MUST come from verified 
 * token metadata sources, not from hardcoded assumptions.
 */
export interface LiquidityPoolOptions {
    tokenA: string;
    tokenB: string;
    lpTokenName: string;
    lpTokenSymbol: string;
    swapFee: number;
    initialLiquidityA: number;
    initialLiquidityB: number;
    isTokenAStx?: boolean;
    isTokenBStx?: boolean;
    tokenADecimals: number;
    tokenBDecimals: number;
    contractIdentifier: string; // Full contract principal for the LP token metadata
    lpTokenIdentifier: string; // Full contract principal for the LP token
}

/**
 * Generates a liquidity pool contract for AMM trading
 * 
 * WARNING: This function requires accurate decimal information for all tokens.
 * Never assume decimal places. Always fetch from token metadata.
 */
export function generateLiquidityPoolContract({
    tokenA,
    tokenB,
    lpTokenName,
    lpTokenSymbol,
    swapFee,
    initialLiquidityA,
    initialLiquidityB,
    isTokenAStx = false,
    isTokenBStx = false,
    tokenADecimals,
    tokenBDecimals,
    contractIdentifier, // Full contract principal for the LP token
    lpTokenIdentifier,
}: LiquidityPoolOptions): string {
    // Helper function to generate transfer code based on token type
    const generateTransferIn = (isStx: boolean, tokenContract: string, amount: string, sender: string, recipient: string): string => {
        return isStx
            ? `(try! (stx-transfer? ${amount} ${sender} ${recipient}))`
            : `(try! (contract-call? '${tokenContract} transfer ${amount} ${sender} ${recipient} none))`;
    };

    const generateTransferOut = (isStx: boolean, tokenContract: string, amount: string, sender: string, recipient: string): string => {
        return isStx
            ? `(try! (as-contract (stx-transfer? ${amount} ${sender} ${recipient})))`
            : `(try! (as-contract (contract-call? '${tokenContract} transfer ${amount} ${sender} ${recipient} none)))`;
    };

    const getBalance = (isStx: boolean, tokenContract: string, owner: string): string => {
        return isStx
            ? `(stx-get-balance ${owner})`
            : `(unwrap-panic (contract-call? '${tokenContract} get-balance ${owner}))`;
    };

    // Create the token URI
    const tokenUri = `https://metadata.charisma.rocks/api/v1/metadata/${contractIdentifier}`;

    // Create the main contract with the core functionality
    const contract = `
;; Title: ${lpTokenName}
;; Version: 1.0.0
;; Description: 
;;   Implementation of the standard trait interface for liquidity pools on the Stacks blockchain.
;;   Provides automated market making functionality between two SIP-010 compliant tokens.
;;   Implements SIP-010 fungible token standard for LP token compatibility.
;;   Generated by Charisma Launchpad

;; Traits
(impl-trait 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.charisma-traits-v1.sip010-ft-trait)
(impl-trait 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.dexterity-traits-v0.liquidity-pool-trait)

;; Constants
(define-constant DEPLOYER tx-sender)
(define-constant CONTRACT (as-contract tx-sender))
(define-constant ERR_UNAUTHORIZED (err u403))
(define-constant ERR_INVALID_OPERATION (err u400))
(define-constant PRECISION u1000000)
(define-constant LP_REBATE u${swapFee})

;; Opcodes
(define-constant OP_SWAP_A_TO_B 0x00)      ;; Swap token A for B
(define-constant OP_SWAP_B_TO_A 0x01)      ;; Swap token B for A
(define-constant OP_ADD_LIQUIDITY 0x02)    ;; Add liquidity
(define-constant OP_REMOVE_LIQUIDITY 0x03) ;; Remove liquidity
(define-constant OP_LOOKUP_RESERVES 0x04)  ;; Read pool reserves

;; Define LP token
(define-fungible-token ${lpTokenIdentifier})
(define-data-var token-uri (optional (string-utf8 256)) none)

;; --- SIP10 Functions ---

(define-public (transfer (amount uint) (sender principal) (recipient principal) (memo (optional (buff 34))))
    (begin
        (asserts! (is-eq tx-sender sender) ERR_UNAUTHORIZED)
        (try! (ft-transfer? ${lpTokenIdentifier} amount sender recipient))
        (match memo to-print (print to-print) 0x0000)
        (ok true)))

(define-read-only (get-name)
    (ok "${lpTokenName}"))

(define-read-only (get-symbol)
    (ok "${lpTokenSymbol}"))

(define-read-only (get-decimals)
    (ok u6))

(define-read-only (get-balance (who principal))
    (ok (ft-get-balance ${lpTokenIdentifier} who)))

(define-read-only (get-total-supply)
    (ok (ft-get-supply ${lpTokenIdentifier})))

(define-read-only (get-token-uri)
    (ok (var-get token-uri)))

(define-public (set-token-uri (uri (string-utf8 256)))
    (if (is-eq contract-caller DEPLOYER)
        (ok (var-set token-uri (some uri))) 
        ERR_UNAUTHORIZED))

;; --- Core Functions ---

(define-public (execute (amount uint) (opcode (optional (buff 16))))
    (let (
        (sender tx-sender)
        (operation (get-byte (default-to 0x00 opcode) u0)))
        (if (is-eq operation OP_SWAP_A_TO_B) (swap-a-to-b amount)
        (if (is-eq operation OP_SWAP_B_TO_A) (swap-b-to-a amount)
        (if (is-eq operation OP_ADD_LIQUIDITY) (add-liquidity amount)
        (if (is-eq operation OP_REMOVE_LIQUIDITY) (remove-liquidity amount)
        ERR_INVALID_OPERATION))))))

(define-read-only (quote (amount uint) (opcode (optional (buff 16))))
    (let (
        (operation (get-byte (default-to 0x00 opcode) u0)))
        (if (is-eq operation OP_SWAP_A_TO_B) (ok (get-swap-quote amount (some 0x00)))
        (if (is-eq operation OP_SWAP_B_TO_A) (ok (get-swap-quote amount (some 0x01)))
        (if (is-eq operation OP_ADD_LIQUIDITY) (ok (get-liquidity-quote amount))
        (if (is-eq operation OP_REMOVE_LIQUIDITY) (ok (get-liquidity-quote amount))
        (if (is-eq operation OP_LOOKUP_RESERVES) (ok (get-reserves-quote))
        ERR_INVALID_OPERATION)))))))

;; --- Execute Functions ---

(define-public (swap-a-to-b (amount uint))
    (let (
        (sender tx-sender)
        (delta (get-swap-quote amount (some 0x00))))
        ;; Transfer token A to pool
        ${generateTransferIn(isTokenAStx, tokenA, 'amount', 'sender', 'CONTRACT')}
        ;; Transfer token B to sender
        ${generateTransferOut(isTokenBStx, tokenB, '(get dy delta)', 'CONTRACT', 'sender')}
        (print {op: "swap-a-to-b", sender: sender, amount: amount, delta: delta})
        (ok delta)))

(define-public (swap-b-to-a (amount uint))
    (let (
        (sender tx-sender)
        (delta (get-swap-quote amount (some 0x01))))
        ;; Transfer token B to pool
        ${generateTransferIn(isTokenBStx, tokenB, 'amount', 'sender', 'CONTRACT')}
        ;; Transfer token A to sender
        ${generateTransferOut(isTokenAStx, tokenA, '(get dy delta)', 'CONTRACT', 'sender')}
        (print {op: "swap-b-to-a", sender: sender, amount: amount, delta: delta})
        (ok delta)))

(define-public (add-liquidity (amount uint))
    (let (
        (sender tx-sender)
        (delta (get-liquidity-quote amount)))
        ${generateTransferIn(isTokenAStx, tokenA, '(get dx delta)', 'sender', 'CONTRACT')}
        ${generateTransferIn(isTokenBStx, tokenB, '(get dy delta)', 'sender', 'CONTRACT')}
        (try! (ft-mint? ${lpTokenIdentifier} (get dk delta) sender))
        (print {op: "add-liquidity", sender: sender, amount: amount, delta: delta})
        (ok delta)))

(define-public (remove-liquidity (amount uint))
    (let (
        (sender tx-sender)
        (delta (get-liquidity-quote amount)))
        (try! (ft-burn? ${lpTokenIdentifier} (get dk delta) sender))
        ${generateTransferOut(isTokenAStx, tokenA, '(get dx delta)', 'CONTRACT', 'sender')}
        ${generateTransferOut(isTokenBStx, tokenB, '(get dy delta)', 'CONTRACT', 'sender')}
        (print {op: "remove-liquidity", sender: sender, amount: amount, delta: delta})
        (ok delta)))

;; --- Helper Functions ---

(define-private (get-byte (opcode (buff 16)) (position uint))
    (default-to 0x00 (element-at? opcode position)))

(define-private (get-reserves)
    { 
      a: ${getBalance(isTokenAStx, tokenA, 'CONTRACT')}, 
      b: ${getBalance(isTokenBStx, tokenB, 'CONTRACT')}
    })

;; --- Quote Functions ---

(define-read-only (get-swap-quote (amount uint) (opcode (optional (buff 16))))
    (let (
        (reserves (get-reserves))
        (operation (get-byte (default-to 0x00 opcode) u0))
        (is-a-in (is-eq operation OP_SWAP_A_TO_B))
        (x (if is-a-in (get a reserves) (get b reserves)))
        (y (if is-a-in (get b reserves) (get a reserves)))
        (dx (/ (* amount (- PRECISION LP_REBATE)) PRECISION))
        (numerator (* dx y))
        (denominator (+ x dx))
        (dy (/ numerator denominator)))
        {
          dx: dx,
          dy: dy,
          dk: u0
        }))

(define-read-only (get-liquidity-quote (amount uint))
    (let (
        (k (ft-get-supply ${lpTokenIdentifier}))
        (reserves (get-reserves)))
        {
          dx: (if (> k u0) (/ (* amount (get a reserves)) k) amount),
          dy: (if (> k u0) (/ (* amount (get b reserves)) k) amount),
          dk: amount
        }))

(define-read-only (get-reserves-quote)
    (let (
        (reserves (get-reserves))
        (supply (ft-get-supply ${lpTokenIdentifier})))
        {
          dx: (get a reserves),
          dy: (get b reserves),
          dk: supply
        }))`;

    // Generate initialization logic if initial liquidity is provided
    if (initialLiquidityA > 0 || initialLiquidityB > 0) {
        // Scale the initial liquidity values by their respective decimal places to get atomic units
        const initialLiquidityAScaled = Math.floor(initialLiquidityA * Math.pow(10, tokenADecimals));
        const initialLiquidityBScaled = Math.floor(initialLiquidityB * Math.pow(10, tokenBDecimals));

        // Calculate the base amount (minimum of both token amounts)
        const baseAmount = Math.min(initialLiquidityAScaled, initialLiquidityBScaled);

        // Calculate additional amounts for each token
        const additionalTokenA = Math.max(0, initialLiquidityAScaled - baseAmount);
        const additionalTokenB = Math.max(0, initialLiquidityBScaled - baseAmount);

        // Format the amounts as strings without scientific notation
        const formattedBaseAmount = baseAmount.toLocaleString('fullwide', {
            useGrouping: false,
            maximumFractionDigits: 0
        });

        const formattedAdditionalA = additionalTokenA.toLocaleString('fullwide', {
            useGrouping: false,
            maximumFractionDigits: 0
        });

        const formattedAdditionalB = additionalTokenB.toLocaleString('fullwide', {
            useGrouping: false,
            maximumFractionDigits: 0
        });

        let initBlock = `

;; --- Initialization ---
(begin
    ;; Set token URI
    (var-set token-uri (some u"${tokenUri}"))`;

        if (baseAmount > 0) {
            // Use add-liquidity for balanced liquidity with the normalized amount
            initBlock += `
    ;; Add initial balanced liquidity (handles both token transfers at 1:1)
    (try! (add-liquidity u${formattedBaseAmount}))`;
        }

        if (additionalTokenA > 0) {
            initBlock += `
    ;; Transfer additional token A to achieve desired ratio
    ${generateTransferIn(
                isTokenAStx,
                tokenA,
                `u${formattedAdditionalA}`,
                'tx-sender',
                'CONTRACT'
            )}`;
        }

        if (additionalTokenB > 0) {
            initBlock += `
    ;; Transfer additional token B to achieve desired ratio
    ${generateTransferIn(
                isTokenBStx,
                tokenB,
                `u${formattedAdditionalB}`,
                'tx-sender',
                'CONTRACT'
            )}`;
        }

        initBlock += `
)`;

        return contract + initBlock;
    }

    return contract + `

;; --- Initialization ---
(begin
    ;; Set token URI
    (var-set token-uri (some u"${tokenUri}"))
)`;
} 