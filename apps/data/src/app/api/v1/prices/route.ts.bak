import { NextRequest, NextResponse } from 'next/server';
import { oraclePriceService } from '@/lib/prices';
import { blobStorageService } from '@/lib/storage/blob-storage-service';
import { generateCacheHeaders } from '@/lib/utils/cache-strategy';

export const runtime = 'edge';

const PRICES_BLOB_PATH = 'prices/current';
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

/**
 * GET /api/v1/prices - Get all token prices with oracle integration
 * 
 * Flow:
 * 1. Try to get from blob storage first (fastest)
 * 2. On cache miss, fetch from oracle service
 * 3. Update blob storage with fresh data
 * 4. Return prices to client
 */
export async function GET(request: NextRequest) {
  const startTime = Date.now();

  try {
    const url = new URL(request.url);
    const forceRefresh = url.searchParams.get('refresh') === 'true';
    const tokenIds = url.searchParams.get('tokens')?.split(',') || [];
    
    console.log('[Prices API] Getting token prices', { 
      forceRefresh, 
      tokenCount: tokenIds.length || 'all' 
    });

    let prices: Record<string, any> = {};
    let dataSource = 'unknown';
    let cacheHit = false;

    // Step 1: Try blob storage first (unless forced refresh)
    if (!forceRefresh) {
      try {
        const blobData = await blobStorageService.get(PRICES_BLOB_PATH);
        
        if (blobData && typeof blobData === 'object') {
          const blobTimestamp = blobData.timestamp || 0;
          const age = Date.now() - blobTimestamp;
          
          if (age < CACHE_TTL) {
            console.log(`[Prices API] Using blob cache (age: ${Math.round(age / 1000)}s)`);
            prices = blobData.prices || blobData; // Handle both formats
            dataSource = 'blob-cache';
            cacheHit = true;
          } else {
            console.log(`[Prices API] Blob cache expired (age: ${Math.round(age / 1000)}s), fetching fresh data`);
          }
        }
      } catch (error) {
        console.log('[Prices API] Blob cache miss, will fetch from oracle service');
      }
    }

    // Step 2: Cache miss or forced refresh - get from oracle service
    if (!cacheHit || forceRefresh) {
      try {
        console.log('[Prices API] Fetching from oracle service...');
        
        if (tokenIds.length > 0) {
          // Get specific tokens
          prices = await oraclePriceService.getMultiplePrices(tokenIds);
        } else {
          // Get all available prices
          prices = await oraclePriceService.getAllPrices();
          
          // If oracle service returns empty, try to get from known token list
          if (Object.keys(prices).length === 0) {
            console.log('[Prices API] Oracle service returned empty, trying known tokens');
            const knownTokens = await getKnownTokenList();
            if (knownTokens.length > 0) {
              prices = await oraclePriceService.getMultiplePrices(knownTokens);
            }
          }
        }

        dataSource = forceRefresh ? 'oracle-refresh' : 'oracle-miss';

        // Step 3: Update blob storage with fresh data (background)
        if (Object.keys(prices).length > 0) {
          const blobData = {
            prices,
            timestamp: Date.now(),
            tokenCount: Object.keys(prices).length,
            source: 'oracle-service'
          };

          // Save to blob (don't wait)
          blobStorageService.put(PRICES_BLOB_PATH, blobData).catch(error => {
            console.warn('[Prices API] Failed to update blob storage:', error);
          });

          console.log(`[Prices API] Updated blob storage with ${Object.keys(prices).length} prices`);
        }
      } catch (error) {
        console.error('[Prices API] Error fetching from oracle service:', error);
        
        // Fallback: try to return stale blob data if available
        try {
          const staleData = await blobStorageService.get(PRICES_BLOB_PATH);
          if (staleData && typeof staleData === 'object') {
            console.log('[Prices API] Returning stale blob data as fallback');
            prices = staleData.prices || staleData;
            dataSource = 'stale-blob';
          }
        } catch (fallbackError) {
          console.warn('[Prices API] Fallback to stale data also failed');
        }
      }
    }

    // Generate appropriate cache headers
    const cachePolicy = cacheHit 
      ? { sMaxAge: 300, staleWhileRevalidate: 900, browserCache: 60 }
      : { sMaxAge: 60, staleWhileRevalidate: 300, browserCache: 30 }; // Shorter cache for fresh data

    const cacheHeaders = generateCacheHeaders(cachePolicy, {
      deploymentId: process.env.VERCEL_DEPLOYMENT_ID
    });

    const processingTime = Date.now() - startTime;
    cacheHeaders.set('X-Response-Time', `${processingTime}ms`);
    cacheHeaders.set('X-Data-Source', dataSource);
    cacheHeaders.set('X-Cache-Hit', cacheHit.toString());
    cacheHeaders.set('X-Price-Count', Object.keys(prices).length.toString());

    // Add oracle service stats
    try {
      const stats = oraclePriceService.getStats();
      cacheHeaders.set('X-Oracle-Stats', JSON.stringify({
        adapters: stats.totalAdapters,
        cacheSize: stats.cacheSize
      }));
    } catch (error) {
      // Ignore stats errors
    }

    console.log(`[Prices API] Returning ${Object.keys(prices).length} prices from ${dataSource} in ${processingTime}ms`);

    return NextResponse.json(prices, { headers: cacheHeaders });

  } catch (error) {
    console.error('[Prices API] Unexpected error:', error);

    return NextResponse.json(
      {
        error: 'Failed to fetch token prices',
        message: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString()
      },
      { status: 500 }
    );
  }
}

/**
 * POST /api/v1/prices - Force refresh prices for specific tokens
 */
export async function POST(request: NextRequest) {
  const startTime = Date.now();

  try {
    const body = await request.json();
    const tokenIds = body.tokenIds || body.tokens || [];
    
    if (!Array.isArray(tokenIds) || tokenIds.length === 0) {
      return NextResponse.json(
        { error: 'tokenIds array is required' },
        { status: 400 }
      );
    }

    console.log(`[Prices API] Force refreshing ${tokenIds.length} tokens`);

    // Force refresh from oracle service
    await oraclePriceService.refreshAndSavePrices(tokenIds);

    // Get the refreshed prices
    const prices = await oraclePriceService.getMultiplePrices(tokenIds);

    // Update blob storage
    const blobData = {
      prices,
      timestamp: Date.now(),
      tokenCount: Object.keys(prices).length,
      source: 'forced-refresh'
    };

    await blobStorageService.put(PRICES_BLOB_PATH, blobData);

    const processingTime = Date.now() - startTime;

    console.log(`[Prices API] Force refreshed ${Object.keys(prices).length} prices in ${processingTime}ms`);

    return NextResponse.json({
      success: true,
      refreshed: Object.keys(prices).length,
      requested: tokenIds.length,
      processingTime: `${processingTime}ms`,
      prices,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('[Prices API] Error in POST:', error);

    return NextResponse.json(
      {
        error: 'Failed to refresh prices',
        message: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString()
      },
      { status: 500 }
    );
  }
}

/**
 * Get known token list from contracts or fallback list
 */
async function getKnownTokenList(): Promise<string[]> {
  try {
    // Try to get from contracts blob
    const contracts = await blobStorageService.get('contracts');
    
    if (contracts && typeof contracts === 'object') {
      // Extract contract IDs
      const contractIds = Object.keys(contracts);
      console.log(`[Prices API] Found ${contractIds.length} contracts for price fetching`);
      return contractIds;
    }
  } catch (error) {
    console.warn('[Prices API] Could not get contracts list:', error);
  }

  // Fallback to known popular tokens
  return [
    'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.charisma-token',
    'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token',
    'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token',
    'SP3K8BC0PPEVCV7NZ6QSRWPQ2JE9E5B6N3PA0KBR9.alex-token',
    'SP1H1733V5MZ3SZ9XRW9FKYGEZT0JDGEB8Y634C7R.miamicoin-token',
  ];
}